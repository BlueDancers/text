# JavaScript隐式转换

```
1 + '1'                                                     '11'
1 - '1'                                                     '0'
'2' + '2' - '2'                                             '20'
[] + []
{} + {}
[] + {}
{} + []
[] + {} === {} + []
{} + [] === [] + {}
[+false] + [+false] + [+false]
[+false] + [+false] + [+false] - [+false]
'1' == true
parseInt('infinity') == 0 / 0
1 < 2 < 3
3 > 2 > 1
isNaN(false)
isNaN(null)
[[][[]]+[]][+[]][++[+[]][+[]]]

```

- 如果两个操作数都是基础类型，`操作符会判断至少一个是字符串类型并且执行连接操作。其他情况都转化为数字并且求和`,								这就是为什么1+‘1’为11

- 虽然`-`操作符和`+`操作符看看上去性质相同，但`-`操作符只有一个功能，就是数值上的相减。它会尝试把非数值类型的操作数转化为数值类型，如果转化的结果是`NaN`, 那么表达式的结果可想而知也就是`NaN`，如果全部都转化成功，则执行减法操作                  这就是为什么1-‘1’为0              '2' + '2' - '2' 为20

- `[] + []` 的结果是 `''` 空字符串，因为数组是对象类型，转化为基础类型的结果是空字符串，拼接之后仍然是空字符串                      [].join(',')+[].join(',') = > ""+"" => ""

- `[] + {}` 的结果是 `[object Object]`，因为操作数有对象类型的关系，两个操作数都需要转化为基础类型，`[]`转化为基础类型的结果是`''`，`{}`转化为基础类型的结果是`[object Object]`，最后字符串拼接的结果仍然是`[object Object]`    [].join(',')+{}  = > [object Object]

- `{} + []` 的结果是`0`。因为在这个表达式中，开头`{}`并不是空对象的字面量，而是被当作空的代码块。事实上这个表达式的值就是`+[]`的结果，即`Number([].join(','))`，即为`0`

- 更奇怪的是`{} + {}`这个表达式，在不同的浏览器中执行会得到不同的结果。
  按照上面的例子，我们可以同理推出这个表达式的值实际上是`+{}`的值，即最后的结果是`Number([object Object])`，即`NaN`。在 IE 11 中的执行结果却是是如此，但是如果在 Chrome 中执行，你得到的结果是 `[object Object][object Object]`。

- `[+false] + [+false] + [+false]`的结果也可想而知了，`+false`的结果是`false`转化为数字`0`，之后`[0]`又被转化为基础类型字符串`'0'`，所以表达式最后的结果是`'000'` 

   [0].toString() = > "0" "0"+"0"+"0" = >"000"
